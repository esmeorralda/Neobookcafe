<!-- 전체 배경 -->
<div class="min-h-screen bg-[#f7f1ea] flex flex-col">
  <!-- 상단 여백 제거 -->
  <main class="flex-1">
<div class="max-w-2xl mx-auto bg-white p-6 rounded-xl shadow space-y-6 mt-5">

  <h2 class="text-xl font-bold text-gray-800">
    <% if @note&.book.present? %>
      <%= @note.book.title %>
    <% elsif @note&.book_id == "new_book" %>
      <%= params[:note][:book_title].presence || "새로운 메모" %>
    <% else %>
      새로운 메모
    <% end %>
  </h2>

  <%= form_with(model: @note, local: true) do |f| %>

    <!-- 📘 책 선택 -->
    <div id="book_select_wrapper" class="mb-4">
      <%= label_tag :book_id, "책 선택 또는 새로 입력", class: "block font-medium mb-1" %>
      <%= select_tag "note[book_id]",
          options_for_select(
            [["📖 새로운 책 입력", "new_book"]] + current_user.books.pluck(:title, :id),
            selected: @note.book_id
          ),
          prompt: "책을 선택하세요",
          class: "w-full border border-gray-300 rounded p-2",
          id: "book_select" %>
    </div>

    <!-- 새 책 제목 입력 필드 (초기엔 숨김) -->
    <div id="new_book_title_field" class="mb-4 hidden">
      <%= label_tag "note[book_title]", "새 책 제목", class: "block font-medium mb-1" %>
      <%= text_field_tag "note[book_title]", nil, placeholder: "예: 나미야 잡화점의 기적", class: "w-full border border-gray-300 rounded p-2" %>
    </div>

   

    <!-- 쪽수와 목차 영역만 그리드 -->
    <!-- 새 책 제목 입력 필드 (초기엔 숨김) -->
   <div class="flex items-center space-x-6"> <!-- items-center로 세로 중앙 정렬 -->
   

    <div class="flex flex-col space-y-2">
     <label for="page_from_field " class="block font-medium mb-1 text-sm text-gray-700 leading-6">범위</label> <!-- 폰트 크기, 줄높이 동일하게 -->
      <div class="flex items-center space-x-2 mb-2">
     
        <%= f.number_field :page_from, id: "page_from_field", class: "w-20 border border-gray-300 rounded-md p-2 text-sm" %>
      <span class="text-sm text-gray-700 leading-6">쪽부터 ~ </span>
      <%= f.number_field :page_to, class: "w-20 border border-gray-300 rounded-md p-2 text-sm" %>
      <span class="text-sm text-gray-700 leading-6">쪽까지</span>
      </div>
      </div>


      <!-- 목차 드롭다운 영역 -->
      <div  class="flex flex-col flex-1 space-y-2" id="chapter_select_wrapper">
         <%= label_tag :chapter_id, "목차 선택 또는 새로 입력", class: "block font-medium mb-1 text-sm text-gray-700 leading-6", id: "chapter_select_label" %>  
       <%= select_tag "note[chapter_id]",
        options_for_select(
          (@chapters || []).map { |ch| [ch.title, ch.id] } + [["➕ 새로운 목차 입력", "new_chapter"]],
          selected: @note.chapter_id
        ),
        prompt: "목차를 선택하세요",
        class: "w-full border border-gray-300 rounded p-2",
        id: "chapter_select" %>

    <div id="new_chapter_title_field" class="mt-2 hidden">
      <%= label_tag "note[chapter_title]", "새 목차 제목", class: "block font-medium mb-1 text-sm text-gray-700 leading-6" %>
      <%= text_field_tag "note[chapter_title]", nil, placeholder: "예: 1장 시작하기", class: "w-full border border-gray-300 rounded p-2" %>
    </div>
      </div>
    </div>

    <!-- 색상 선택 (그리드 바깥) -->
    <div>
      <%= f.label :color, "색상", class: "block text-sm font-medium text-gray-700 mb-2" %>
      <div class="flex space-x-4">
        <% [['#FFFFCD'], ['#E3FFDC'], ['#FFF0F8'], ['#E1FAFF']].each_with_index do |(hex), index| %>
          <label class="cursor-pointer">
            <%= f.radio_button :color, hex, id: "color_#{index}", class: "hidden peer", checked: @note.color.blank? && hex == "#FFFFCD" %>
            <span class="w-8 h-8 rounded-full border-2 border-gray-300 peer-checked:ring-2 ring-offset-2 ring-blue-500 inline-block" style="background-color: <%= hex %>"></span>
          </label>
        <% end %>
      </div>
    </div>

    <!-- 🧠 메모 입력 영역 (그리드 바깥, 중앙 정렬, 너비 제한) -->
    <div class="space-y-6 w-full flex flex-col items-center mt-6">
     <div class="w-full max-w-[600px]">
  <%= f.label :memo, "메모를 남겨주세요", class: "block text-sm font-medium text-gray-700 mb-1" %>
  <%= f.text_area :memo, rows: 10, class: "block w-full border border-gray-300 rounded-md shadow-sm p-3 resize-none", id: "auto-resize-textarea" %>
</div>

      <div class="flex justify-end gap-4 w-full max-w-[600px]">
        <%= f.submit "저장", class: "bg-[#644536] rounded text-white py-2 px-4 rounded-sm" %>
        <%= link_to "취소", new_note_path, class: "rounded bg-gray-300 hover:bg-gray-400 text-gray-800 py-2 px-4 rounded-sm flex items-center justify-center" %>
        <% if @note.persisted? %>
          <%= link_to "삭제", note_path(@note), method: :delete, data: { confirm: "정말 삭제할까요?" }, class: "bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-sm flex items-center justify-center" %>
        <% end %>
      </div>
    </div>

  <% end %>
</div>

</main>

</div>
<!-- ✅ JS: 책 선택 → 새 입력란 표시 + 목차 로딩 및 새로운 목차 입력란 토글 -->
<script>
(function () {
  // ===== 작은 스켈레톤 (챕터 영역/로딩) =====
  const CHAPTER_SKELETON_HTML = `
    <div id="chapter-skeleton" class="animate-pulse" style="display:flex; gap:.5rem; margin:.25rem 0;">
      <div style="height:22px; width:140px; background:#eee; border-radius:6px;"></div>
      <div style="height:22px; width:90px; background:#eee; border-radius:6px;"></div>
    </div>
  `;
  function showChapterSkeleton(wrapper) {
    if (!wrapper || wrapper.querySelector("#chapter-skeleton")) return;
    const wrap = document.createElement("div");
    wrap.innerHTML = CHAPTER_SKELETON_HTML;
    wrapper.prepend(wrap.firstElementChild);
  }
  function hideChapterSkeleton(wrapper) {
    const sk = wrapper && wrapper.querySelector("#chapter-skeleton");
    if (sk) sk.remove();
  }

  // ===== 유틸: 보이기/숨기기 토글 =====
  function toggle(el, show) {
    if (!el) return;
    el.classList.toggle("hidden", !show);
  }

  // ===== 핵심 바인딩 (한 페이지 내 중복 바인딩 방지) =====
  function initNoteForm() {
    // DOM 재조회 (Turbo 전환 대비)
    const bookSelect      = document.getElementById("book_select");
    const bookWrapper     = document.getElementById("book_select_wrapper");
    const newBookField    = document.getElementById("new_book_title_field");

    const chapterSelect   = document.getElementById("chapter_select");
    const chapterWrapper  = document.getElementById("chapter_select_wrapper");
    const newChapterField = document.getElementById("new_chapter_title_field");

    const chapterLabel    = document.getElementById("chapter_select_label");

    const pageFromField   = document.getElementById("page_from_field");

    // 요소가 없으면 스킵
    if (!bookSelect) return;

    // 중복 바인딩 방지 플래그
    if (bookSelect.dataset.bound === "1") {
      // 바인딩은 되어있더라도, 첫 렌더/복귀 시 상태 보정은 해준다
      applyInitialState();
      return;
    }
    bookSelect.dataset.bound = "1";

    // --- 상태 토글 함수들 ---
    function toggleBookField() {
      const isNewBook = (bookSelect.value === "new_book");

      toggle(newBookField, isNewBook);
      toggle(bookWrapper, !isNewBook);

      if (isNewBook) {
        // 새 책 입력이면 챕터 드롭다운은 숨기고, 새 챕터 입력 필드만 보여줌
        toggle(chapterWrapper, false);
        toggle(chapterLabel, false);
        toggle(newChapterField, true);
      } else {
        // 기존 책이면 챕터 드롭/라벨을 보여주고, 새 챕터 입력 필드는 숨김
        toggle(chapterWrapper, true);
        toggle(chapterLabel, true);
        toggle(newChapterField, false);
      }
    }

    function toggleChapterField() {
      if (!chapterSelect) return;
      const isNewChapter = (chapterSelect.value === "new_chapter");
      toggle(chapterSelect, !isNewChapter);
      toggle(newChapterField, isNewChapter);
      if (chapterLabel) chapterLabel.classList.toggle("hidden", isNewChapter);
    }

    // --- Ajax 로 챕터/현재 페이지 가져오기 ---
    async function loadChapters(bookId) {
      if (!bookId || bookId === "new_book") return;

      try {
        // 로딩 스켈레톤
        showChapterSkeleton(chapterWrapper);

        const response = await fetch(`/books/${bookId}/chapters_and_current_page`, {
          headers: { "Accept": "application/json" }
        });
        if (!response.ok) throw new Error("Failed to fetch chapters");

        const data = await response.json();
        const chapters = Array.isArray(data.chapters) ? data.chapters : [];

        if (chapterSelect) {
          // 기존 옵션 제거
          chapterSelect.innerHTML = "";
          // 챕터 채우기
          chapters.forEach(ch => {
            const option = document.createElement("option");
            option.value = ch.id;
            option.text  = ch.title;
            chapterSelect.appendChild(option);
          });
          // 새 챕터 옵션
          const newOption = document.createElement("option");
          newOption.value = "new_chapter";
          newOption.text  = "➕ 새로운 목차 입력";
          chapterSelect.appendChild(newOption);

          // 드롭다운/라벨 표시, 새 챕터 입력 숨김
          toggle(chapterWrapper, true);
          chapterSelect.classList.remove("hidden");
          toggle(newChapterField, false);
          if (chapterLabel) chapterLabel.classList.remove("hidden");
        }

        // current_page + 1 → page_from 자동 입력
        if (pageFromField) {
          const currentPage = parseInt(data.current_page, 10);
          pageFromField.value = isNaN(currentPage) ? "" : (currentPage + 1);
        }
      } catch (err) {
        console.error("Ajax error:", err);
        if (chapterSelect) chapterSelect.innerHTML = "";
      } finally {
        hideChapterSkeleton(chapterWrapper);
      }
    }

    // --- 이벤트 바인딩 ---
    bookSelect.addEventListener("change", () => {
      toggleBookField();
      if (bookSelect.value && bookSelect.value !== "new_book") {
        loadChapters(bookSelect.value);
      }
    });

    if (chapterSelect && !chapterSelect.dataset.bound) {
      chapterSelect.dataset.bound = "1";
      chapterSelect.addEventListener("change", toggleChapterField);
    }

    // --- 초기 상태 적용 ---
    function applyInitialState() {
      toggleBookField();

      // 기존 책이 선택된 상태라면 챕터/페이지 즉시 로드
      if (bookSelect.value && bookSelect.value !== "new_book") {
        loadChapters(bookSelect.value);
      }

      // chapterSelect가 이미 렌더되어 있을 수 있으므로 상태 보정
      toggleChapterField();
    }
    // 다음 프레임에 초기 상태 적용(레이아웃 안정 후)
    requestAnimationFrame(applyInitialState);

    // --- 폼 유효성 검사 (해당 폼 1개에만 바인딩) ---
    const form = bookSelect.closest("form") || document.querySelector("form");
    if (form && !form.dataset.bound) {
      form.dataset.bound = "1";
      form.addEventListener("submit", function (e) {
        const bookId   = bookSelect.value;
        const bookTitleInput = document.querySelector("input[name='note[book_title]']");
        const bookTitle = bookTitleInput ? bookTitleInput.value.trim() : "";

        const chapterId = chapterSelect ? chapterSelect.value : "";
        const chapterTitleInput = document.querySelector("input[name='note[chapter_title]']");
        const chapterTitle = chapterTitleInput ? chapterTitleInput.value.trim() : "";

        const memoEl = document.querySelector("textarea[name='note[memo]']");
        const memo   = memoEl ? memoEl.value.trim() : "";
        const pageTo   = (document.querySelector("input[name='note[page_to]']")   || {}).value;
        const pageFrom = (document.querySelector("input[name='note[page_from]']") || {}).value;

        if (bookId === "new_book" && bookTitle === "") {
          alert("새 책 제목을 입력해주세요.");
          e.preventDefault(); return;
        }
        if (!bookId) {
          alert("책을 선택하거나 새로 입력해주세요.");
          e.preventDefault(); return;
        }
        if ((bookId !== "new_book") && (!chapterId || (chapterId === "new_chapter" && chapterTitle === ""))) {
          alert("목차를 선택하거나 새로 입력해주세요.");
          e.preventDefault(); return;
        }
        if (memo === "") {
          alert("메모 내용을 입력해주세요.");
          e.preventDefault(); return;
        }
        if (!pageTo || isNaN(parseInt(pageTo, 10))) {
          alert("마지막 쪽 수(page_to)를 입력해주세요.");
          e.preventDefault(); return;
        }
        if (pageFrom && pageTo && parseInt(pageFrom, 10) > parseInt(pageTo, 10)) {
          alert("시작 쪽은 끝 쪽보다 작거나 같아야 합니다.");
          e.preventDefault(); return;
        }
      });
    }

    // --- 텍스트에어리어 자동 리사이즈 (#auto-resize-textarea) ---
    const noteTextarea = document.getElementById("auto-resize-textarea");
    if (noteTextarea && !noteTextarea.dataset.bound) {
      noteTextarea.dataset.bound = "1";
      const resizeTextarea = () => {
        noteTextarea.style.height = "auto";
        noteTextarea.style.height = noteTextarea.scrollHeight + "px";
      };
      noteTextarea.addEventListener("input", resizeTextarea);
      requestAnimationFrame(resizeTextarea);
    }
  }

  // ===== Turbo 대응: 모든 네비게이션에서 보장 =====
  function initAll() {
    initNoteForm();
  }
  document.addEventListener("DOMContentLoaded", initAll);
  document.addEventListener("turbo:load", initAll);
  document.addEventListener("turbo:render", initAll);
})();
</script>
